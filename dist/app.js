// Generated by CoffeeScript 1.9.0

/*
Represents a polygonal jewel
 */

(function() {
  var Gem, app;

  Gem = (function() {
    function Gem(options) {
      this.color = options.color, this.type = options.type;
      this.exploded = false;
      this.highlight = false;
      this.angle = Math.round(Math.random() * 360);
      this.points = this.getPolygonPoints();
    }

    Gem.prototype.getPolygonPoints = function() {
      var base, center, size, _i, _ref, _results;
      size = 200;
      center = size / 2;
      base = 2 * Math.PI / this.type;
      return ((function() {
        _results = [];
        for (var _i = 0, _ref = this.type; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(index) {
        var angle;
        angle = base * (index + 0.5);
        return ([center + center * Math.cos(angle), center + center * Math.sin(angle)].map(function(n) {
          return n.toFixed(0);
        })).join(' ');
      })).join(',');
    };

    return Gem;

  })();


  /*
  The type of gem determines how many angles it has
   */

  Gem.Types = [5, 6, 8, 12];


  /*
  The color of the gem
   */

  Gem.Colors = ['red', 'green', 'blue', 'yellow', 'violet'];

  app = angular.module('gem-puzzle', ['ngAnimate']);

  app.controller('GemController', function($scope, $timeout) {
    var _i, _ref, _results, _results1;
    this.matchNumber = 3;
    this.size = 8;
    this.tiles = (function() {
      _results = [];
      for (var _i = 0, _ref = this.size * this.size; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this);
    this.gems = [];
    this.highlighted = [];

    /*
    Creates a gem with random type and color
     */
    this.randomGem = function() {
      return new Gem({
        color: Gem.Colors[Math.floor(Math.random() * Gem.Colors.length)],
        type: Gem.Types[Math.floor(Math.random() * Gem.Types.length)]
      });
    };

    /*
    If the selected gem forms a string with adjusent gems of the
    same color, they get "exploded"
     */
    this.explode = function(gem) {
      var linked;
      linked = this.getLinked(gem);
      if (linked) {
        linked.forEach((function(_this) {
          return function(index) {
            return _this.gems[index].exploded = true;
          };
        })(this));
        return $timeout((function(_this) {
          return function() {
            return _this.reorder();
          };
        })(this), 300);
      }
    };

    /*
    Reorders the gems so that the exploded gems are replaced
    with the gems from the line above
     */
    this.reorder = function() {
      var _j, _ref1, _results1;
      this.gems.forEach((function(_this) {
        return function(gem, index) {
          if (gem.exploded) {
            return _this.gems[index] = null;
          }
        };
      })(this));
      return (function() {
        _results1 = [];
        for (var _j = _ref1 = this.size * this.size - 1; _ref1 <= 0 ? _j <= 0 : _j >= 0; _ref1 <= 0 ? _j++ : _j--){ _results1.push(_j); }
        return _results1;
      }).apply(this).forEach((function(_this) {
        return function(index) {
          var gem, upperIndex;
          gem = _this.gems[index];
          if (!gem) {
            upperIndex = index;
            while (upperIndex >= _this.size && !gem) {
              upperIndex = upperIndex - _this.size;
              gem = _this.gems[upperIndex];
              _this.gems[upperIndex] = null;
            }
            if (gem) {
              return _this.gems[index] = new Gem({
                type: gem.type,
                color: gem.color
              });
            } else {
              return _this.gems[index] = _this.randomGem();
            }
          }
        };
      })(this));
    };

    /*
    Highlights a string of linked gems
     */
    this.highlightOn = function(gem) {
      var linked;
      linked = this.getLinked(gem);
      if (linked) {
        return this.highlighted = linked.map((function(_this) {
          return function(index) {
            gem = _this.gems[index];
            gem.highlight = true;
            return gem;
          };
        })(this));
      }
    };

    /*
    Un-highlights previously highlighted gems
     */
    this.highlightOff = function() {
      this.highlighted.forEach(function(gem) {
        return gem.highlight = false;
      });
      return this.highlighted = [];
    };

    /*
    Gets a string of subsequent gems of the same color.
    The string can be a straight line or a polyline,
    but not a diagonal line
     */
    this.getLinked = function(firstGem) {
      var gem, index, linked, queue;
      linked = [];
      queue = [this.gems.indexOf(firstGem)];
      while (queue.length) {
        index = queue.pop();
        if (linked.indexOf(index) === -1) {
          gem = this.gems[index];
          if (gem && gem.color === firstGem.color) {
            linked.push(index);
            if (index === 0 || (index + 1) % this.size) {
              queue.push(index + 1);
            }
            if (index % this.size) {
              queue.push(index - 1);
            }
            queue.push(index + this.size);
            queue.push(index - this.size);
          }
        }
      }
      if (linked.length >= this.matchNumber) {
        return linked;
      }
    };

    /*
    Checks end game conditions
     */
    this.isEndGame = function() {
      return !this.gems.some((function(gem) {
        return !!this.getLinked(gem);
      }), this);
    };
    _results1 = [];
    while (this.isEndGame()) {
      _results1.push(this.gems = this.tiles.map(this.randomGem, this));
    }
    return _results1;
  });

}).call(this);
