// Generated by CoffeeScript 1.9.0

/*
Represents a polygonal jewel
 */

(function() {
  var Gem, app;

  Gem = (function() {
    function Gem(options) {
      this.color = options.color, this.type = options.type;
      this.exploded = false;
      this.highlight = false;
      this.angle = Math.round(Math.random() * 360);
      this.points = this.getPolygonPoints();
    }

    Gem.prototype.getPolygonPoints = function() {
      var base, center, size, _i, _ref, _results;
      size = 200;
      center = size / 2;
      base = 2 * Math.PI / this.type;
      return ((function() {
        _results = [];
        for (var _i = 0, _ref = this.type; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).map(function(index) {
        var angle;
        angle = base * (index + 0.5);
        return ([center + center * Math.cos(angle), center + center * Math.sin(angle)].map(function(n) {
          return n.toFixed(0);
        })).join(' ');
      })).join(',');
    };

    return Gem;

  })();


  /*
  The type of gem determines how many angles it has
   */

  Gem.Types = [5, 6, 8, 12];


  /*
  The color of the gem
   */

  Gem.Colors = ['red', 'green', 'blue', 'yellow', 'violet'];

  app = angular.module('gem-puzzle', ['ngAnimate']);

  app.controller('GemController', function($scope, $timeout) {
    var randomGem, _i, _ref, _results;
    this.matchNumber = 3;
    this.size = 8;
    this.gems = [];
    this.highlighted = [];

    /*
    Creates a gem with random type and color
     */
    randomGem = function() {
      return new Gem({
        color: Gem.Colors[Math.floor(Math.random() * Gem.Colors.length)],
        type: Gem.Types[Math.floor(Math.random() * Gem.Types.length)]
      });
    };

    /*
    If the selected gem forms a string with adjusent gems of the
    same color, they get "exploded"
     */
    this.explode = function(gem) {
      var adjacent;
      adjacent = this.getAdjacent(gem);
      if (adjacent.length >= this.matchNumber) {
        adjacent.forEach((function(_this) {
          return function(index) {
            return _this.gems[index].exploded = true;
          };
        })(this));
        return $timeout((function(_this) {
          return function() {
            return _this.reorder();
          };
        })(this), 300);
      }
    };

    /*
    Reorders the gems so that the exploded gems are replaced
    with the gems from the line above
     */
    this.reorder = function() {
      var _i, _ref, _results;
      this.gems.forEach((function(_this) {
        return function(gem, index) {
          if (gem.exploded) {
            return _this.gems[index] = null;
          }
        };
      })(this));
      return (function() {
        _results = [];
        for (var _i = _ref = this.size * this.size - 1; _ref <= 0 ? _i <= 0 : _i >= 0; _ref <= 0 ? _i++ : _i--){ _results.push(_i); }
        return _results;
      }).apply(this).forEach((function(_this) {
        return function(index) {
          var gem, upperIndex;
          gem = _this.gems[index];
          if (!gem) {
            upperIndex = index;
            while (upperIndex >= _this.size && !gem) {
              upperIndex = upperIndex - _this.size;
              gem = _this.gems[upperIndex];
              _this.gems[upperIndex] = null;
            }
            if (gem) {
              return _this.gems[index] = new Gem({
                type: gem.type,
                color: gem.color
              });
            } else {
              return _this.gems[index] = randomGem();
            }
          }
        };
      })(this));
    };

    /*
    Highlights a string of adjacent gems
     */
    this.highlightOn = function(gem) {
      var indeces;
      indeces = this.getAdjacent(gem);
      if (indeces.length >= this.matchNumber) {
        return this.highlighted = indeces.map((function(_this) {
          return function(index) {
            gem = _this.gems[index];
            gem.highlight = true;
            return gem;
          };
        })(this));
      }
    };

    /*
    Un-highlights previously highlighted gems
     */
    this.highlightOff = function() {
      this.highlighted.forEach(function(gem) {
        return gem.highlight = false;
      });
      return this.highlighted = [];
    };

    /*
    Gets a string of subsequent gems of the same color.
    The string can be a straight line or a polyline,
    but not a diagonal line
     */
    this.getAdjacent = function(firstGem) {
      var adjacent, gem, index, queue;
      adjacent = [];
      queue = [this.gems.indexOf(firstGem)];
      while (queue.length) {
        index = queue.pop();
        if (adjacent.indexOf(index) === -1) {
          gem = this.gems[index];
          if (gem && gem.color === firstGem.color) {
            adjacent.push(index);
            if (index === 0 || (index + 1) % this.size) {
              queue.push(index + 1);
            }
            if (index % this.size) {
              queue.push(index - 1);
            }
            queue.push(index + this.size);
            queue.push(index - this.size);
          }
        }
      }
      return adjacent;
    };
    return this.gems = (function() {
      _results = [];
      for (var _i = 0, _ref = this.size * this.size; 0 <= _ref ? _i < _ref : _i > _ref; 0 <= _ref ? _i++ : _i--){ _results.push(_i); }
      return _results;
    }).apply(this).map(randomGem);
  });

}).call(this);
